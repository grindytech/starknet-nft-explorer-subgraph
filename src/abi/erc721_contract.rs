// ****
// Auto-generated by cainome do not edit.
// ****

#[derive(Debug)]
pub struct erc721<A: starknet::accounts::ConnectedAccount + Sync> {
    pub address: starknet::core::types::Felt,
    pub account: A,
    pub block_id: starknet::core::types::BlockId,
}
impl<A: starknet::accounts::ConnectedAccount + Sync> erc721<A> {
    pub fn new(address: starknet::core::types::Felt, account: A) -> Self {
        Self {
            address,
            account,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &A::Provider {
        self.account.provider()
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(Debug)]
pub struct erc721Reader<P: starknet::providers::Provider + Sync> {
    pub address: starknet::core::types::Felt,
    pub provider: P,
    pub block_id: starknet::core::types::BlockId,
}
impl<P: starknet::providers::Provider + Sync> erc721Reader<P> {
    pub fn new(address: starknet::core::types::Felt, provider: P) -> Self {
        Self {
            address,
            provider,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &P {
        &self.provider
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Approval {
    pub owner: cainome::cairo_serde::ContractAddress,
    pub approved: cainome::cairo_serde::ContractAddress,
    pub token_id: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for Approval {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.approved,
            );
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.token_id);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.owner),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.approved),
            );
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.token_id));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&owner);
        let approved = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&approved);
        let token_id = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&token_id);
        Ok(Approval {
            owner,
            approved,
            token_id,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct ApprovalForAll {
    pub owner: cainome::cairo_serde::ContractAddress,
    pub operator: cainome::cairo_serde::ContractAddress,
    pub approved: bool,
}
impl cainome::cairo_serde::CairoSerde for ApprovalForAll {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.operator,
            );
        __size += bool::cairo_serialized_size(&__rust.approved);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.owner),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.operator),
            );
        __out.extend(bool::cairo_serialize(&__rust.approved));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&owner);
        let operator = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&operator);
        let approved = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&approved);
        Ok(ApprovalForAll {
            owner,
            operator,
            approved,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct RoleAdminChanged {
    pub role: starknet::core::types::Felt,
    pub previous_admin_role: starknet::core::types::Felt,
    pub new_admin_role: starknet::core::types::Felt,
}
impl cainome::cairo_serde::CairoSerde for RoleAdminChanged {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet::core::types::Felt::cairo_serialized_size(&__rust.role);
        __size
            += starknet::core::types::Felt::cairo_serialized_size(
                &__rust.previous_admin_role,
            );
        __size
            += starknet::core::types::Felt::cairo_serialized_size(
                &__rust.new_admin_role,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(starknet::core::types::Felt::cairo_serialize(&__rust.role));
        __out
            .extend(
                starknet::core::types::Felt::cairo_serialize(&__rust.previous_admin_role),
            );
        __out
            .extend(
                starknet::core::types::Felt::cairo_serialize(&__rust.new_admin_role),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let role = starknet::core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet::core::types::Felt::cairo_serialized_size(&role);
        let previous_admin_role = starknet::core::types::Felt::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += starknet::core::types::Felt::cairo_serialized_size(&previous_admin_role);
        let new_admin_role = starknet::core::types::Felt::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += starknet::core::types::Felt::cairo_serialized_size(&new_admin_role);
        Ok(RoleAdminChanged {
            role,
            previous_admin_role,
            new_admin_role,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct RoleGranted {
    pub role: starknet::core::types::Felt,
    pub account: cainome::cairo_serde::ContractAddress,
    pub sender: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for RoleGranted {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet::core::types::Felt::cairo_serialized_size(&__rust.role);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.account,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.sender,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(starknet::core::types::Felt::cairo_serialize(&__rust.role));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.account),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.sender),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let role = starknet::core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet::core::types::Felt::cairo_serialized_size(&role);
        let account = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&account);
        let sender = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&sender);
        Ok(RoleGranted {
            role,
            account,
            sender,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct RoleRevoked {
    pub role: starknet::core::types::Felt,
    pub account: cainome::cairo_serde::ContractAddress,
    pub sender: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for RoleRevoked {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet::core::types::Felt::cairo_serialized_size(&__rust.role);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.account,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.sender,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(starknet::core::types::Felt::cairo_serialize(&__rust.role));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.account),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.sender),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let role = starknet::core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet::core::types::Felt::cairo_serialized_size(&role);
        let account = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&account);
        let sender = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&sender);
        Ok(RoleRevoked {
            role,
            account,
            sender,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Transfer {
    pub from: cainome::cairo_serde::ContractAddress,
    pub to: cainome::cairo_serde::ContractAddress,
    pub token_id: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for Transfer {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.from,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&__rust.to);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.token_id);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.from),
            );
        __out.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.to));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.token_id));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let from = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&from);
        let to = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&to);
        let token_id = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&token_id);
        Ok(Transfer { from, to, token_id })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum AccessControlComponentEvent {
    RoleGranted(RoleGranted),
    RoleRevoked(RoleRevoked),
    RoleAdminChanged(RoleAdminChanged),
}
impl cainome::cairo_serde::CairoSerde for AccessControlComponentEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            AccessControlComponentEvent::RoleGranted(val) => {
                RoleGranted::cairo_serialized_size(val) + 1
            }
            AccessControlComponentEvent::RoleRevoked(val) => {
                RoleRevoked::cairo_serialized_size(val) + 1
            }
            AccessControlComponentEvent::RoleAdminChanged(val) => {
                RoleAdminChanged::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            AccessControlComponentEvent::RoleGranted(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(RoleGranted::cairo_serialize(val));
                temp
            }
            AccessControlComponentEvent::RoleRevoked(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(RoleRevoked::cairo_serialize(val));
                temp
            }
            AccessControlComponentEvent::RoleAdminChanged(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&2usize));
                temp.extend(RoleAdminChanged::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    AccessControlComponentEvent::RoleGranted(
                        RoleGranted::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    AccessControlComponentEvent::RoleRevoked(
                        RoleRevoked::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            2usize => {
                Ok(
                    AccessControlComponentEvent::RoleAdminChanged(
                        RoleAdminChanged::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!(
                            "Index not handle for enum {}", "AccessControlComponentEvent"
                        ),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for AccessControlComponentEvent {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RoleGranted")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "RoleGranted"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "role",
                            "RoleGranted", e
                        ),
                    );
                }
            };
            data_offset += starknet::core::types::Felt::cairo_serialized_size(&role);
            let account = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "account",
                            "RoleGranted", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &account,
                );
            let sender = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "sender",
                            "RoleGranted", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&sender);
            return Ok(
                AccessControlComponentEvent::RoleGranted(RoleGranted {
                    role,
                    account,
                    sender,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RoleRevoked")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "RoleRevoked"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "role",
                            "RoleRevoked", e
                        ),
                    );
                }
            };
            data_offset += starknet::core::types::Felt::cairo_serialized_size(&role);
            let account = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "account",
                            "RoleRevoked", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &account,
                );
            let sender = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "sender",
                            "RoleRevoked", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&sender);
            return Ok(
                AccessControlComponentEvent::RoleRevoked(RoleRevoked {
                    role,
                    account,
                    sender,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RoleAdminChanged")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "RoleAdminChanged")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "role",
                            "RoleAdminChanged", e
                        ),
                    );
                }
            };
            data_offset += starknet::core::types::Felt::cairo_serialized_size(&role);
            let previous_admin_role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_admin_role", "RoleAdminChanged", e
                        ),
                    );
                }
            };
            data_offset
                += starknet::core::types::Felt::cairo_serialized_size(
                    &previous_admin_role,
                );
            let new_admin_role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_admin_role", "RoleAdminChanged", e
                        ),
                    );
                }
            };
            data_offset
                += starknet::core::types::Felt::cairo_serialized_size(&new_admin_role);
            return Ok(
                AccessControlComponentEvent::RoleAdminChanged(RoleAdminChanged {
                    role,
                    previous_admin_role,
                    new_admin_role,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum ERC721ComponentEvent {
    Transfer(Transfer),
    Approval(Approval),
    ApprovalForAll(ApprovalForAll),
}
impl cainome::cairo_serde::CairoSerde for ERC721ComponentEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            ERC721ComponentEvent::Transfer(val) => {
                Transfer::cairo_serialized_size(val) + 1
            }
            ERC721ComponentEvent::Approval(val) => {
                Approval::cairo_serialized_size(val) + 1
            }
            ERC721ComponentEvent::ApprovalForAll(val) => {
                ApprovalForAll::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            ERC721ComponentEvent::Transfer(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(Transfer::cairo_serialize(val));
                temp
            }
            ERC721ComponentEvent::Approval(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(Approval::cairo_serialize(val));
                temp
            }
            ERC721ComponentEvent::ApprovalForAll(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&2usize));
                temp.extend(ApprovalForAll::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    ERC721ComponentEvent::Transfer(
                        Transfer::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    ERC721ComponentEvent::Approval(
                        Approval::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            2usize => {
                Ok(
                    ERC721ComponentEvent::ApprovalForAll(
                        ApprovalForAll::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "ERC721ComponentEvent"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for ERC721ComponentEvent {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Transfer")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Transfer"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let from = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "from",
                            "Transfer", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&from);
            let to = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "to",
                            "Transfer", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&to);
            let token_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "token_id",
                            "Transfer", e
                        ),
                    );
                }
            };
            key_offset += cainome::cairo_serde::U256::cairo_serialized_size(&token_id);
            return Ok(ERC721ComponentEvent::Transfer(Transfer { from, to, token_id }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Approval")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Approval"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "owner",
                            "Approval", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&owner);
            let approved = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "approved",
                            "Approval", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &approved,
                );
            let token_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "token_id",
                            "Approval", e
                        ),
                    );
                }
            };
            key_offset += cainome::cairo_serde::U256::cairo_serialized_size(&token_id);
            return Ok(
                ERC721ComponentEvent::Approval(Approval {
                    owner,
                    approved,
                    token_id,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("ApprovalForAll")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "ApprovalForAll"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "owner",
                            "ApprovalForAll", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&owner);
            let operator = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "operator",
                            "ApprovalForAll", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &operator,
                );
            let approved = match bool::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "approved",
                            "ApprovalForAll", e
                        ),
                    );
                }
            };
            data_offset += bool::cairo_serialized_size(&approved);
            return Ok(
                ERC721ComponentEvent::ApprovalForAll(ApprovalForAll {
                    owner,
                    operator,
                    approved,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum Event {
    AccessControlEvent(AccessControlComponentEvent),
    ERC721Event(ERC721ComponentEvent),
    SRC5Event(SRC5ComponentEvent),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::AccessControlEvent(val) => {
                AccessControlComponentEvent::cairo_serialized_size(val) + 1
            }
            Event::ERC721Event(val) => {
                ERC721ComponentEvent::cairo_serialized_size(val) + 1
            }
            Event::SRC5Event(val) => SRC5ComponentEvent::cairo_serialized_size(val) + 1,
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            Event::AccessControlEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(AccessControlComponentEvent::cairo_serialize(val));
                temp
            }
            Event::ERC721Event(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(ERC721ComponentEvent::cairo_serialize(val));
                temp
            }
            Event::SRC5Event(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&2usize));
                temp.extend(SRC5ComponentEvent::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    Event::AccessControlEvent(
                        AccessControlComponentEvent::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            1usize => {
                Ok(
                    Event::ERC721Event(
                        ERC721ComponentEvent::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            2usize => {
                Ok(
                    Event::SRC5Event(
                        SRC5ComponentEvent::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RoleGranted")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "RoleGranted"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "role",
                            "RoleGranted", e
                        ),
                    );
                }
            };
            data_offset += starknet::core::types::Felt::cairo_serialized_size(&role);
            let account = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "account",
                            "RoleGranted", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &account,
                );
            let sender = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "sender",
                            "RoleGranted", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&sender);
            return Ok(
                Event::AccessControlEvent(
                    AccessControlComponentEvent::RoleGranted(RoleGranted {
                        role,
                        account,
                        sender,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RoleRevoked")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "RoleRevoked"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "role",
                            "RoleRevoked", e
                        ),
                    );
                }
            };
            data_offset += starknet::core::types::Felt::cairo_serialized_size(&role);
            let account = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "account",
                            "RoleRevoked", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &account,
                );
            let sender = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "sender",
                            "RoleRevoked", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&sender);
            return Ok(
                Event::AccessControlEvent(
                    AccessControlComponentEvent::RoleRevoked(RoleRevoked {
                        role,
                        account,
                        sender,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RoleAdminChanged")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "RoleAdminChanged")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "role",
                            "RoleAdminChanged", e
                        ),
                    );
                }
            };
            data_offset += starknet::core::types::Felt::cairo_serialized_size(&role);
            let previous_admin_role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_admin_role", "RoleAdminChanged", e
                        ),
                    );
                }
            };
            data_offset
                += starknet::core::types::Felt::cairo_serialized_size(
                    &previous_admin_role,
                );
            let new_admin_role = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_admin_role", "RoleAdminChanged", e
                        ),
                    );
                }
            };
            data_offset
                += starknet::core::types::Felt::cairo_serialized_size(&new_admin_role);
            return Ok(
                Event::AccessControlEvent(
                    AccessControlComponentEvent::RoleAdminChanged(RoleAdminChanged {
                        role,
                        previous_admin_role,
                        new_admin_role,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Transfer")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Transfer"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let from = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "from",
                            "Transfer", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&from);
            let to = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "to",
                            "Transfer", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&to);
            let token_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "token_id",
                            "Transfer", e
                        ),
                    );
                }
            };
            key_offset += cainome::cairo_serde::U256::cairo_serialized_size(&token_id);
            return Ok(
                Event::ERC721Event(
                    ERC721ComponentEvent::Transfer(Transfer { from, to, token_id }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Approval")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Approval"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "owner",
                            "Approval", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&owner);
            let approved = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "approved",
                            "Approval", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &approved,
                );
            let token_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "token_id",
                            "Approval", e
                        ),
                    );
                }
            };
            key_offset += cainome::cairo_serde::U256::cairo_serialized_size(&token_id);
            return Ok(
                Event::ERC721Event(
                    ERC721ComponentEvent::Approval(Approval {
                        owner,
                        approved,
                        token_id,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("ApprovalForAll")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "ApprovalForAll"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "owner",
                            "ApprovalForAll", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&owner);
            let operator = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "operator",
                            "ApprovalForAll", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &operator,
                );
            let approved = match bool::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "approved",
                            "ApprovalForAll", e
                        ),
                    );
                }
            };
            data_offset += bool::cairo_serialized_size(&approved);
            return Ok(
                Event::ERC721Event(
                    ERC721ComponentEvent::ApprovalForAll(ApprovalForAll {
                        owner,
                        operator,
                        approved,
                    }),
                ),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum SRC5ComponentEvent {}
impl cainome::cairo_serde::CairoSerde for SRC5ComponentEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "SRC5ComponentEvent"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for SRC5ComponentEvent {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
impl<A: starknet::accounts::ConnectedAccount + Sync> erc721<A> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn balanceOf(
        &self,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("balanceOf"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn balance_of(
        &self,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("balance_of"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn baseURI(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ByteArray,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("baseURI"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn getApproved(
        &self,
        tokenId: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("getApproved"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn getMaxTokenId(
        &self,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("getMaxTokenId"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn getRoyalty(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        (cainome::cairo_serde::U256, cainome::cairo_serde::ContractAddress),
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("getRoyalty"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_approved(
        &self,
        token_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_approved"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_role_admin(
        &self,
        role: &starknet::core::types::Felt,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, starknet::core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_role_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn has_role(
        &self,
        role: &starknet::core::types::Felt,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("has_role"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn isApprovedForAll(
        &self,
        owner: &cainome::cairo_serde::ContractAddress,
        operator: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(owner));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(operator));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("isApprovedForAll"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_approved_for_all(
        &self,
        owner: &cainome::cairo_serde::ContractAddress,
        operator: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(owner));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(operator));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("is_approved_for_all"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn name(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ByteArray,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("name"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn ownerOf(
        &self,
        tokenId: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("ownerOf"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn owner_of(
        &self,
        token_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("owner_of"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn royalty_info(
        &self,
        token_id: &cainome::cairo_serde::U256,
        sale_price: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        (cainome::cairo_serde::ContractAddress, cainome::cairo_serde::U256),
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(sale_price));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("royalty_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn supports_interface(
        &self,
        interface_id: &starknet::core::types::Felt,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(interface_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("supports_interface"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn symbol(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ByteArray,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("symbol"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn tokenURI(
        &self,
        tokenId: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ByteArray,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("tokenURI"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn token_uri(
        &self,
        token_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ByteArray,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("token_uri"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn approve_getcall(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        token_id: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("approve"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn approve(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        token_id: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("approve"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn grant_role_getcall(
        &self,
        role: &starknet::core::types::Felt,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("grant_role"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn grant_role(
        &self,
        role: &starknet::core::types::Felt,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("grant_role"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mint_getcall(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mint"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mint(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mint"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mintBatch_getcall(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenIds: &Vec<cainome::cairo_serde::U256>,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(Vec::<cainome::cairo_serde::U256>::cairo_serialize(tokenIds));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mintBatch"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mintBatch(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenIds: &Vec<cainome::cairo_serde::U256>,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(Vec::<cainome::cairo_serde::U256>::cairo_serialize(tokenIds));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mintBatch"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mint_batch_getcall(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenIds: &Vec<cainome::cairo_serde::U256>,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(Vec::<cainome::cairo_serde::U256>::cairo_serialize(tokenIds));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mint_batch"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mint_batch(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenIds: &Vec<cainome::cairo_serde::U256>,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(Vec::<cainome::cairo_serde::U256>::cairo_serialize(tokenIds));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mint_batch"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn renounce_role_getcall(
        &self,
        role: &starknet::core::types::Felt,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("renounce_role"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn renounce_role(
        &self,
        role: &starknet::core::types::Felt,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("renounce_role"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn revoke_role_getcall(
        &self,
        role: &starknet::core::types::Felt,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("revoke_role"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn revoke_role(
        &self,
        role: &starknet::core::types::Felt,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("revoke_role"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safeMint_getcall(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safeMint"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safeMint(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safeMint"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safeMintBatch_getcall(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenIds: &Vec<cainome::cairo_serde::U256>,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(Vec::<cainome::cairo_serde::U256>::cairo_serialize(tokenIds));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safeMintBatch"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safeMintBatch(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenIds: &Vec<cainome::cairo_serde::U256>,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(Vec::<cainome::cairo_serde::U256>::cairo_serialize(tokenIds));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safeMintBatch"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safeTransferFrom_getcall(
        &self,
        from: &cainome::cairo_serde::ContractAddress,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(from));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safeTransferFrom"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safeTransferFrom(
        &self,
        from: &cainome::cairo_serde::ContractAddress,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(from));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safeTransferFrom"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safe_mint_getcall(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safe_mint"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safe_mint(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safe_mint"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safe_mint_batch_getcall(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenIds: &Vec<cainome::cairo_serde::U256>,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(Vec::<cainome::cairo_serde::U256>::cairo_serialize(tokenIds));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safe_mint_batch"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safe_mint_batch(
        &self,
        to: &cainome::cairo_serde::ContractAddress,
        tokenIds: &Vec<cainome::cairo_serde::U256>,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(Vec::<cainome::cairo_serde::U256>::cairo_serialize(tokenIds));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safe_mint_batch"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safe_transfer_from_getcall(
        &self,
        from: &cainome::cairo_serde::ContractAddress,
        to: &cainome::cairo_serde::ContractAddress,
        token_id: &cainome::cairo_serde::U256,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(from));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safe_transfer_from"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn safe_transfer_from(
        &self,
        from: &cainome::cairo_serde::ContractAddress,
        to: &cainome::cairo_serde::ContractAddress,
        token_id: &cainome::cairo_serde::U256,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(from));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("safe_transfer_from"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn setApprovalForAll_getcall(
        &self,
        operator: &cainome::cairo_serde::ContractAddress,
        approved: &bool,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(operator));
        __calldata.extend(bool::cairo_serialize(approved));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("setApprovalForAll"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn setApprovalForAll(
        &self,
        operator: &cainome::cairo_serde::ContractAddress,
        approved: &bool,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(operator));
        __calldata.extend(bool::cairo_serialize(approved));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("setApprovalForAll"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn setBaseURI_getcall(
        &self,
        newBaseURI: &cainome::cairo_serde::ByteArray,
        newMaxTokenId: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(newBaseURI));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(newMaxTokenId));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("setBaseURI"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn setBaseURI(
        &self,
        newBaseURI: &cainome::cairo_serde::ByteArray,
        newMaxTokenId: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(newBaseURI));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(newMaxTokenId));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("setBaseURI"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn setRoyalty_getcall(
        &self,
        royaltyPercentage: &cainome::cairo_serde::U256,
        royaltyReceiver: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::U256::cairo_serialize(royaltyPercentage));
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(royaltyReceiver),
            );
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("setRoyalty"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn setRoyalty(
        &self,
        royaltyPercentage: &cainome::cairo_serde::U256,
        royaltyReceiver: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::U256::cairo_serialize(royaltyPercentage));
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(royaltyReceiver),
            );
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("setRoyalty"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn set_approval_for_all_getcall(
        &self,
        operator: &cainome::cairo_serde::ContractAddress,
        approved: &bool,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(operator));
        __calldata.extend(bool::cairo_serialize(approved));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("set_approval_for_all"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn set_approval_for_all(
        &self,
        operator: &cainome::cairo_serde::ContractAddress,
        approved: &bool,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(operator));
        __calldata.extend(bool::cairo_serialize(approved));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("set_approval_for_all"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transferFrom_getcall(
        &self,
        from: &cainome::cairo_serde::ContractAddress,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(from));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transferFrom"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transferFrom(
        &self,
        from: &cainome::cairo_serde::ContractAddress,
        to: &cainome::cairo_serde::ContractAddress,
        tokenId: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(from));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transferFrom"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_from_getcall(
        &self,
        from: &cainome::cairo_serde::ContractAddress,
        to: &cainome::cairo_serde::ContractAddress,
        token_id: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(from));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_from"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_from(
        &self,
        from: &cainome::cairo_serde::ContractAddress,
        to: &cainome::cairo_serde::ContractAddress,
        token_id: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(from));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(to));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_from"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
}
impl<P: starknet::providers::Provider + Sync> erc721Reader<P> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn balanceOf(
        &self,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("balanceOf"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn balance_of(
        &self,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("balance_of"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn baseURI(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ByteArray> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("baseURI"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn getApproved(
        &self,
        tokenId: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("getApproved"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn getMaxTokenId(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("getMaxTokenId"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn getRoyalty(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        P,
        (cainome::cairo_serde::U256, cainome::cairo_serde::ContractAddress),
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("getRoyalty"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_approved(
        &self,
        token_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_approved"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_role_admin(
        &self,
        role: &starknet::core::types::Felt,
    ) -> cainome::cairo_serde::call::FCall<P, starknet::core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_role_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn has_role(
        &self,
        role: &starknet::core::types::Felt,
        account: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(role));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(account));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("has_role"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn isApprovedForAll(
        &self,
        owner: &cainome::cairo_serde::ContractAddress,
        operator: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(owner));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(operator));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("isApprovedForAll"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_approved_for_all(
        &self,
        owner: &cainome::cairo_serde::ContractAddress,
        operator: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(owner));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(operator));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("is_approved_for_all"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn name(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ByteArray> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("name"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn ownerOf(
        &self,
        tokenId: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("ownerOf"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn owner_of(
        &self,
        token_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("owner_of"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn royalty_info(
        &self,
        token_id: &cainome::cairo_serde::U256,
        sale_price: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        P,
        (cainome::cairo_serde::ContractAddress, cainome::cairo_serde::U256),
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(sale_price));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("royalty_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn supports_interface(
        &self,
        interface_id: &starknet::core::types::Felt,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(interface_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("supports_interface"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn symbol(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ByteArray> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("symbol"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn tokenURI(
        &self,
        tokenId: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ByteArray> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(tokenId));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("tokenURI"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn token_uri(
        &self,
        token_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ByteArray> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(token_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("token_uri"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
}
